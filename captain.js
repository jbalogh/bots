// Generated by CoffeeScript 1.3.1
var SUBTASK_RE, TASK_RE, elapsed;

TASK_RE = /^\[(.+?)] Running (.*)/;

SUBTASK_RE = /^\[(.+?)\] \[(.+?)\] (\w+):\s*(.*)$/;

elapsed = function(start, stop) {
  var str_to_date;
  str_to_date = function(str) {
    var d, i;
    d = (function() {
      var _i, _len, _ref, _results;
      _ref = /(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/.exec(str).slice(1);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        _results.push(parseInt(i));
      }
      return _results;
    })();
    return new Date(d[0], d[1], d[2], d[3], d[4], d[5]);
  };
  return (str_to_date(stop) - str_to_date(start)) / 1000;
};

exports.parselog = function(stream) {
  var date, host, kind, line, msg, prev_task, prev_time, state, task, text, time, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  state = {
    task: "",
    queue: {},
    failed: [],
    completed: []
  };
  _ref = stream.split("\n");
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    line = _ref[_i];
    if (TASK_RE.test(line)) {
      _ref1 = TASK_RE.exec(line).slice(1), date = _ref1[0], task = _ref1[1];
      if (state.task !== "") {
        _ref2 = state.task, prev_time = _ref2[0], prev_task = _ref2[1];
        state.completed.push([prev_task, elapsed(prev_time, date)]);
      }
      state.task = [date, task];
    } else if (SUBTASK_RE.test(line)) {
      _ref3 = SUBTASK_RE.exec(line).slice(1), date = _ref3[0], host = _ref3[1], kind = _ref3[2], text = _ref3[3];
      if (kind === "running") {
        state.queue[host] = text;
      } else if (kind === "finished") {
        _ref4 = /^(.*)\s+\((.*)\)$/.exec(text).slice(1), msg = _ref4[0], time = _ref4[1];
        if (state.queue[host] === msg) {
          delete state.queue[host];
        }
      } else if (kind === "failed") {
        _ref5 = state.task, date = _ref5[0], task = _ref5[1];
        state["failed"].push([date, task, host, text]);
      }
    }
  }
  return state;
};
